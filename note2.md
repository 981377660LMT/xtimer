# 基于协程池架构实现分布式定时器 XTimer

![alt text](common/img/xtimer1.png)

## 1 背景

笔者 2021-2022 年期间工作部门为工效部研发协同效率中心，面向公司内各研发团队提供研效规则实施服务，规则灵活自由，`大量规则涉及定时定点或周期执行.`

![alt text](image.png)

## 3 核心思路

![alt text](image-1.png)

- 纵向分治: 按照时间(分钟)分桶，**桶内是一个有序容器**

- 横向分治: 根据任务id映射到不同的桶

## 4 服务架构

1. 总架构
   1. 定时任务调度流程
      3 个模块 + 2 个协程池
      调度器模块（Scheduler module）、触发器模块（Trigger module）和执行器模块（Executor module）三个模块
      各模块之间存在依赖关系，父模块通过**协程池**的方式异步启动子模块进行工作：
      ![alt text](image-2.png)
   2. 定时任务创建流程
      定时任务创建与 webServer 和 migrator 2 个模块有关
      ![alt text](image-3.png)
      xTimer 提供了 webServer 模块，面向用户提供 api 用于定时器的创建；
      用户激活定时器后，会根据定时器 cron 表达式批量创建定时任务，用于执行；
      此外，迁移器模块（migrator module）会定期将 db 中的定时任务提前加载的 redis 中，采用 zset 有序表进行组织，供触发器模块轮询触发.
2. 调度器模块
   负责二维分片(分时+分桶)的全局统筹分配.
3. 触发器模块
   按时唤醒二维分片内的定时任务
   ![alt text](image-4.png)
   在调度器模块中，`只能保证到 at least once 的语义`. 这是因为实际上没有手段能实现百分之百的分布式事务，
   即无法保证 （1）触发器完成时间分片作业 + （2）延长分布式锁过期时间 这两个动作整体具有原子性
4. 执行器模块
   真正执行定时任务.
   需要幂等去重，bloomFilter+mysql
   接收到的每一笔定时任务可以通过其`定时器 id 和执行时间`戳拼接出一个全局唯一的标识 id，简称为 定时任务 id
   ![alt text](image-5.png)
5. migrator 模块
